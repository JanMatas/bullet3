#include "btMultiBodyWorldImporter.h"

#include "LinearMath/btSerializer.h"
#include "../BulletFileLoader/btBulletFile.h"
#include "../BulletFileLoader/autogenerated/bullet.h"
#include "btBulletWorldImporter.h"
#include "btBulletDynamicsCommon.h"
#include "BulletDynamics/Featherstone/btMultiBody.h"
#include "BulletSoftBody/btSoftMultiBodyDynamicsWorld.h"
#include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"

#include "BulletSoftBody/btSoftBodyData.h"
#include "BulletSoftBody/btSoftBody.h"
#define btSoftBodyData	btSoftBodyFloatData
#define btSoftBodyDataName	"btSoftBodyFloatData"
struct btMultiBodyWorldImporterInternalData
{
	btSoftMultiBodyDynamicsWorld* m_mbDynamicsWorld;
	btHashMap<btHashPtr, btMultiBody*> m_mbMap;
};

btMultiBodyWorldImporter::btMultiBodyWorldImporter(btSoftMultiBodyDynamicsWorld* world)
	:btBulletWorldImporter(world)
{
	m_data = new btMultiBodyWorldImporterInternalData;
	m_data->m_mbDynamicsWorld = world;
}
	

btMultiBodyWorldImporter::~btMultiBodyWorldImporter()
{
	delete m_data;
}

void btMultiBodyWorldImporter::deleteAllData()
{
	btBulletWorldImporter::deleteAllData();
}


static btCollisionObjectDoubleData* getBody0FromContactManifold(btPersistentManifoldDoubleData* manifold)
{
	return (btCollisionObjectDoubleData*)manifold->m_body0;
}
static btCollisionObjectDoubleData* getBody1FromContactManifold(btPersistentManifoldDoubleData* manifold)
{
	return (btCollisionObjectDoubleData*)manifold->m_body1;
}
static btCollisionObjectFloatData* getBody0FromContactManifold(btPersistentManifoldFloatData* manifold)
{
	return (btCollisionObjectFloatData*)manifold->m_body0;
}
static btCollisionObjectFloatData* getBody1FromContactManifold(btPersistentManifoldFloatData* manifold)
{
	return (btCollisionObjectFloatData*)manifold->m_body1;
}


template<class T> void syncContactManifolds(T** contactManifolds, int numContactManifolds, btMultiBodyWorldImporterInternalData* m_data)
{
	m_data->m_mbDynamicsWorld->updateAabbs();
	m_data->m_mbDynamicsWorld->computeOverlappingPairs();
	btDispatcher* dispatcher = m_data->m_mbDynamicsWorld->getDispatcher();

	btDispatcherInfo& dispatchInfo = m_data->m_mbDynamicsWorld->getDispatchInfo();


	if (dispatcher)
	{
		btOverlappingPairCache* pairCache = m_data->m_mbDynamicsWorld->getBroadphase()->getOverlappingPairCache();
		if (dispatcher)
		{
			dispatcher->dispatchAllCollisionPairs(pairCache, dispatchInfo, dispatcher);
		}
		int numExistingManifolds = m_data->m_mbDynamicsWorld->getDispatcher()->getNumManifolds();
		btManifoldArray manifoldArray;
		for (int i = 0; i < pairCache->getNumOverlappingPairs(); i++)
		{
			btBroadphasePair& pair = pairCache->getOverlappingPairArray()[i];
			if (pair.m_algorithm)
			{
				pair.m_algorithm->getAllContactManifolds(manifoldArray);
				//for each existing manifold, search a matching manifoldData and reconstruct
				for (int m = 0; m < manifoldArray.size(); m++)
				{
					btPersistentManifold* existingManifold = manifoldArray[m];
					int uid0 = existingManifold->getBody0()->getBroadphaseHandle()->m_uniqueId;
					int uid1 = existingManifold->getBody1()->getBroadphaseHandle()->m_uniqueId;
					int matchingManifoldIndex = -1;
					for (int q = 0; q < numContactManifolds; q++)
					{
						if (uid0 == getBody0FromContactManifold(contactManifolds[q])->m_uniqueId && uid1 == getBody1FromContactManifold(contactManifolds[q])->m_uniqueId)
						{
							matchingManifoldIndex = q;
						}
					}
					if (matchingManifoldIndex >= 0)
					{
						existingManifold->deSerialize(contactManifolds[matchingManifoldIndex]);
					}
					else
					{
						existingManifold->setNumContacts(0);
						//printf("Issue: cannot find maching contact manifold (%d, %d), may cause issues in determinism.\n", uid0, uid1);
					}

					manifoldArray.clear();
				}
			}
		}
	}

}















template<class T>  void syncSoftBody(T* sbd, btSoftBody* sb)
{
	// btSoftBodyData* sbd = (btSoftBodyData*) dataBuffer;

	// btCollisionObject::serialize(&sbd->m_collisionObjectData, serializer);

	// btHashMap<btHashPtr,int>	m_nodeIndexMap;



	// if (sbd->m_materials)
	// {
	// 	int numElem = sbd->m_numMaterials;

	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		btSoftBody::Material* mat = m_materials[i];
	// 		*memPtr = mat ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)mat) : 0;
	// 		if (!serializer->findPointer(mat))
	// 		{
	// 			//serialize it here
	// 			btChunk* chunk = serializer->allocate(sizeof(SoftBodyMaterialData),1);
	// 			SoftBodyMaterialData* memPtr = (SoftBodyMaterialData*)chunk->m_oldPtr;
	// 			memPtr->m_flags = mat->m_flags;
	// 			memPtr->m_angularStiffness = mat->m_kAST;
	// 			memPtr->m_linearStiffness = mat->m_kLST;
	// 			memPtr->m_volumeStiffness = mat->m_kVST;
	// 			serializer->finalizeChunk(chunk,"SoftBodyMaterialData",BT_SBMATERIAL_CODE,mat);
	// 		}
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftBodyMaterialData",BT_ARRAY_CODE,(void*) &m_materials);
	// }


	

	assert(sbd->m_numNodes == sb->m_nodes.size());
	if (sbd->m_nodes)
	{
		
		int numElem = sbd->m_numNodes;
		// *memPtr = mat ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*)mat) : 0;
		for (int i=0;i<numElem;i++)
		{


			// m_nodes[i].m_f.serializeFloat( memPtr->m_accumulatedForce);
			sb->m_nodes[i].m_f.deSerialize(sbd->m_nodes[i].m_accumulatedForce);
			sb->m_nodes[i].m_area = sbd->m_nodes[i].m_area;
			sb->m_nodes[i].m_battach = sbd->m_nodes[i].m_attach;
			sb->m_nodes[i].m_im = sbd->m_nodes[i].m_inverseMass;
			sb->m_nodes[i].m_n.deSerialize(sbd->m_nodes[i].m_normal);
			sb->m_nodes[i].m_x.deSerialize(sbd->m_nodes[i].m_position);
			sb->m_nodes[i].m_q.deSerialize(sbd->m_nodes[i].m_previousPosition);
			sb->m_nodes[i].m_v.deSerialize(sbd->m_nodes[i].m_velocity);




			// m_nodeIndexMap.insert(&m_nodes[i],i);
		}
	}

	// sbd->m_numLinks = m_links.size();
	// sbd->m_links = sbd->m_numLinks? (SoftBodyLinkData*) serializer->getUniquePointer((void*)&m_links[0]):0;
	// if (sbd->m_links)
	// {
	// 	int sz = sizeof(SoftBodyLinkData);
	// 	int numElem = sbd->m_numLinks;
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	SoftBodyLinkData* memPtr = (SoftBodyLinkData*)chunk->m_oldPtr;
	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		memPtr->m_bbending = m_links[i].m_bbending;
	// 		memPtr->m_material = m_links[i].m_material? (SoftBodyMaterialData*)serializer->getUniquePointer((void*) m_links[i].m_material):0;
	// 		memPtr->m_nodeIndices[0] = m_links[i].m_n[0] ? m_links[i].m_n[0] - &m_nodes[0]: -1;
	// 		memPtr->m_nodeIndices[1] = m_links[i].m_n[1] ? m_links[i].m_n[1] - &m_nodes[0]: -1;
	// 		btAssert(memPtr->m_nodeIndices[0]<m_nodes.size());
	// 		btAssert(memPtr->m_nodeIndices[1]<m_nodes.size());
	// 		memPtr->m_restLength = m_links[i].m_rl;
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftBodyLinkData",BT_ARRAY_CODE,(void*) &m_links[0]);

	// }


	// sbd->m_numFaces = m_faces.size();
	// sbd->m_faces = sbd->m_numFaces? (SoftBodyFaceData*) serializer->getUniquePointer((void*)&m_faces[0]):0;
	// if (sbd->m_faces)
	// {
	// 	int sz = sizeof(SoftBodyFaceData);
	// 	int numElem = sbd->m_numFaces;
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	SoftBodyFaceData* memPtr = (SoftBodyFaceData*)chunk->m_oldPtr;
	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		memPtr->m_material = m_faces[i].m_material ?  (SoftBodyMaterialData*) serializer->getUniquePointer((void*)m_faces[i].m_material): 0;
	// 		m_faces[i].m_normal.serializeFloat(	memPtr->m_normal);
	// 		for (int j=0;j<3;j++)
	// 		{
	// 			memPtr->m_nodeIndices[j] = m_faces[i].m_n[j]? m_faces[i].m_n[j] - &m_nodes[0]: -1;
	// 		}
	// 		memPtr->m_restArea = m_faces[i].m_ra;
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftBodyFaceData",BT_ARRAY_CODE,(void*) &m_faces[0]);
	// }


	// sbd->m_numTetrahedra = m_tetras.size();
	// sbd->m_tetrahedra = sbd->m_numTetrahedra ? (SoftBodyTetraData*) serializer->getUniquePointer((void*)&m_tetras[0]):0;
	// if (sbd->m_tetrahedra)
	// {
	// 	int sz = sizeof(SoftBodyTetraData);
	// 	int numElem = sbd->m_numTetrahedra;
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	SoftBodyTetraData* memPtr = (SoftBodyTetraData*)chunk->m_oldPtr;
	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		for (int j=0;j<4;j++)
	// 		{
	// 			m_tetras[i].m_c0[j].serializeFloat(	memPtr->m_c0[j] );
	// 			memPtr->m_nodeIndices[j] = m_tetras[j].m_n[j]? m_tetras[j].m_n[j]-&m_nodes[0] : -1;
	// 		}
	// 		memPtr->m_c1 = m_tetras[i].m_c1;
	// 		memPtr->m_c2 = m_tetras[i].m_c2;
	// 		memPtr->m_material = m_tetras[i].m_material ? (SoftBodyMaterialData*)serializer->getUniquePointer((void*) m_tetras[i].m_material): 0;
	// 		memPtr->m_restVolume = m_tetras[i].m_rv;
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftBodyTetraData",BT_ARRAY_CODE,(void*) &m_tetras[0]);
	// }

	// sbd->m_numAnchors = m_anchors.size();
	// sbd->m_anchors = sbd->m_numAnchors ? (SoftRigidAnchorData*) serializer->getUniquePointer((void*)&m_anchors[0]):0;
	// if (sbd->m_anchors)
	// {
	// 	int sz = sizeof(SoftRigidAnchorData);
	// 	int numElem = sbd->m_numAnchors;
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	SoftRigidAnchorData* memPtr = (SoftRigidAnchorData*)chunk->m_oldPtr;
	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		m_anchors[i].m_c0.serializeFloat(memPtr->m_c0);
	// 		m_anchors[i].m_c1.serializeFloat(memPtr->m_c1);
	// 		memPtr->m_c2 = m_anchors[i].m_c2;
	// 		m_anchors[i].m_local.serializeFloat(memPtr->m_localFrame);
	// 		memPtr->m_nodeIndex = m_anchors[i].m_node? m_anchors[i].m_node-&m_nodes[0]: -1;
			
	// 		memPtr->m_rigidBody = m_anchors[i].m_body? (btRigidBodyData*)  serializer->getUniquePointer((void*)m_anchors[i].m_body): 0;
	// 		btAssert(memPtr->m_nodeIndex < m_nodes.size());
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftRigidAnchorData",BT_ARRAY_CODE,(void*) &m_anchors[0]);
	// }
	

	// sbd->m_config.m_dynamicFriction = m_cfg.kDF;
	// sbd->m_config.m_baumgarte = m_cfg.kVCF;
	// sbd->m_config.m_pressure = m_cfg.kPR;
	// sbd->m_config.m_aeroModel = this->m_cfg.aeromodel;
	// sbd->m_config.m_lift = m_cfg.kLF;
	// sbd->m_config.m_drag = m_cfg.kDG;
	// sbd->m_config.m_positionIterations = m_cfg.piterations;
	// sbd->m_config.m_driftIterations = m_cfg.diterations;
	// sbd->m_config.m_clusterIterations = m_cfg.citerations;
	// sbd->m_config.m_velocityIterations = m_cfg.viterations;
	// sbd->m_config.m_maxVolume = m_cfg.maxvolume;
	// sbd->m_config.m_damping = m_cfg.kDP;
	// sbd->m_config.m_poseMatch = m_cfg.kMT;
	// sbd->m_config.m_collisionFlags = m_cfg.collisions;
	// sbd->m_config.m_volume = m_cfg.kVC;
	// sbd->m_config.m_rigidContactHardness = m_cfg.kCHR;
	// sbd->m_config.m_kineticContactHardness = m_cfg.kKHR;
	// sbd->m_config.m_softContactHardness = m_cfg.kSHR;
	// sbd->m_config.m_anchorHardness = m_cfg.kAHR;
	// sbd->m_config.m_timeScale = m_cfg.timescale;
	// sbd->m_config.m_maxVolume = m_cfg.maxvolume;
	// sbd->m_config.m_softRigidClusterHardness = m_cfg.kSRHR_CL;
	// sbd->m_config.m_softKineticClusterHardness = m_cfg.kSKHR_CL;
	// sbd->m_config.m_softSoftClusterHardness = m_cfg.kSSHR_CL;
	// sbd->m_config.m_softRigidClusterImpulseSplit = m_cfg.kSR_SPLT_CL;
	// sbd->m_config.m_softKineticClusterImpulseSplit = m_cfg.kSK_SPLT_CL;
	// sbd->m_config.m_softSoftClusterImpulseSplit = m_cfg.kSS_SPLT_CL;

	// //pose for shape matching
	// {
	// 	sbd->m_pose = (SoftBodyPoseData*)serializer->getUniquePointer((void*)&m_pose);

	// 	int sz = sizeof(SoftBodyPoseData);
	// 	btChunk* chunk = serializer->allocate(sz,1);
	// 	SoftBodyPoseData* memPtr = (SoftBodyPoseData*)chunk->m_oldPtr;
		
	// 	m_pose.m_aqq.serializeFloat(memPtr->m_aqq);
	// 	memPtr->m_bframe = m_pose.m_bframe;
	// 	memPtr->m_bvolume = m_pose.m_bvolume;
	// 	m_pose.m_com.serializeFloat(memPtr->m_com);
		
	// 	memPtr->m_numPositions = m_pose.m_pos.size();
	// 	memPtr->m_positions = memPtr->m_numPositions ? (btVector3FloatData*)serializer->getUniquePointer((void*)&m_pose.m_pos[0]): 0;
	// 	if (memPtr->m_numPositions)
	// 	{
	// 		int numElem = memPtr->m_numPositions;
	// 		int sz = sizeof(btVector3Data);
	// 		btChunk* chunk = serializer->allocate(sz,numElem);
	// 		btVector3FloatData* memPtr = (btVector3FloatData*)chunk->m_oldPtr;
	// 		for (int i=0;i<numElem;i++,memPtr++)
	// 		{
	// 			m_pose.m_pos[i].serializeFloat(*memPtr);
	// 		}
	// 		serializer->finalizeChunk(chunk,"btVector3FloatData",BT_ARRAY_CODE,(void*)&m_pose.m_pos[0]);
	// 	}
	// 	memPtr->m_restVolume = m_pose.m_volume;
	// 	m_pose.m_rot.serializeFloat(memPtr->m_rot);
	// 	m_pose.m_scl.serializeFloat(memPtr->m_scale);

	// 	memPtr->m_numWeigts = m_pose.m_wgh.size();
	// 	memPtr->m_weights = memPtr->m_numWeigts? (float*) serializer->getUniquePointer((void*) &m_pose.m_wgh[0]) : 0;
	// 	if (memPtr->m_numWeigts)
	// 	{
			
	// 		int numElem = memPtr->m_numWeigts;
	// 		int sz = sizeof(float);
	// 		btChunk* chunk = serializer->allocate(sz,numElem);
	// 		float* memPtr = (float*) chunk->m_oldPtr;
	// 		for (int i=0;i<numElem;i++,memPtr++)
	// 		{
	// 			*memPtr = m_pose.m_wgh[i];
	// 		}
	// 		serializer->finalizeChunk(chunk,"float",BT_ARRAY_CODE,(void*)&m_pose.m_wgh[0]);
	// 	}

	// 	serializer->finalizeChunk(chunk,"SoftBodyPoseData",BT_ARRAY_CODE,(void*)&m_pose);
	// }

	// //clusters for convex-cluster collision detection

	// sbd->m_numClusters = m_clusters.size();
	// sbd->m_clusters = sbd->m_numClusters? (SoftBodyClusterData*) serializer->getUniquePointer((void*)m_clusters[0]) : 0;
	// if (sbd->m_numClusters)
	// {
	// 	int numElem = sbd->m_numClusters;
	// 	int sz = sizeof(SoftBodyClusterData);
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	SoftBodyClusterData* memPtr = (SoftBodyClusterData*) chunk->m_oldPtr;
	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		memPtr->m_adamping= m_clusters[i]->m_adamping;
	// 		m_clusters[i]->m_av.serializeFloat(memPtr->m_av);
	// 		memPtr->m_clusterIndex = m_clusters[i]->m_clusterIndex;
	// 		memPtr->m_collide = m_clusters[i]->m_collide;
	// 		m_clusters[i]->m_com.serializeFloat(memPtr->m_com);
	// 		memPtr->m_containsAnchor = m_clusters[i]->m_containsAnchor;
	// 		m_clusters[i]->m_dimpulses[0].serializeFloat(memPtr->m_dimpulses[0]);
	// 		m_clusters[i]->m_dimpulses[1].serializeFloat(memPtr->m_dimpulses[1]);
	// 		m_clusters[i]->m_framexform.serializeFloat(memPtr->m_framexform);
	// 		memPtr->m_idmass = m_clusters[i]->m_idmass;
	// 		memPtr->m_imass = m_clusters[i]->m_imass;
	// 		m_clusters[i]->m_invwi.serializeFloat(memPtr->m_invwi);
	// 		memPtr->m_ldamping = m_clusters[i]->m_ldamping;
	// 		m_clusters[i]->m_locii.serializeFloat(memPtr->m_locii);
	// 		m_clusters[i]->m_lv.serializeFloat(memPtr->m_lv);
	// 		memPtr->m_matching = m_clusters[i]->m_matching;
	// 		memPtr->m_maxSelfCollisionImpulse = m_clusters[i]->m_maxSelfCollisionImpulse;
	// 		memPtr->m_ndamping = m_clusters[i]->m_ndamping;
	// 		memPtr->m_ldamping = m_clusters[i]->m_ldamping;
	// 		memPtr->m_adamping = m_clusters[i]->m_adamping;
	// 		memPtr->m_selfCollisionImpulseFactor = m_clusters[i]->m_selfCollisionImpulseFactor;

	// 		memPtr->m_numFrameRefs = m_clusters[i]->m_framerefs.size();
	// 		memPtr->m_numMasses = m_clusters[i]->m_masses.size();
	// 		memPtr->m_numNodes = m_clusters[i]->m_nodes.size();

	// 		memPtr->m_nvimpulses = m_clusters[i]->m_nvimpulses;
	// 		m_clusters[i]->m_vimpulses[0].serializeFloat(memPtr->m_vimpulses[0]);
	// 		m_clusters[i]->m_vimpulses[1].serializeFloat(memPtr->m_vimpulses[1]);
	// 		memPtr->m_ndimpulses = m_clusters[i]->m_ndimpulses;

			

	// 		memPtr->m_framerefs = memPtr->m_numFrameRefs? (btVector3FloatData*)serializer->getUniquePointer((void*)&m_clusters[i]->m_framerefs[0]) : 0;
	// 		if (memPtr->m_framerefs)
	// 		{
	// 			int numElem = memPtr->m_numFrameRefs;
	// 			int sz = sizeof(btVector3FloatData);
	// 			btChunk* chunk = serializer->allocate(sz,numElem);
	// 			btVector3FloatData* memPtr = (btVector3FloatData*) chunk->m_oldPtr;
	// 			for (int j=0;j<numElem;j++,memPtr++)
	// 			{
	// 				m_clusters[i]->m_framerefs[j].serializeFloat(*memPtr);
	// 			}
	// 			serializer->finalizeChunk(chunk,"btVector3FloatData",BT_ARRAY_CODE,(void*)&m_clusters[i]->m_framerefs[0]);
	// 		}
			
	// 		memPtr->m_masses = memPtr->m_numMasses ? (float*) serializer->getUniquePointer((void*)&m_clusters[i]->m_masses[0]): 0;
	// 		if (memPtr->m_masses)
	// 		{
	// 			int numElem = memPtr->m_numMasses;
	// 			int sz = sizeof(float);
	// 			btChunk* chunk = serializer->allocate(sz,numElem);
	// 			float* memPtr = (float*) chunk->m_oldPtr;
	// 			for (int j=0;j<numElem;j++,memPtr++)
	// 			{
	// 				*memPtr = m_clusters[i]->m_masses[j];
	// 			}
	// 			serializer->finalizeChunk(chunk,"float",BT_ARRAY_CODE,(void*)&m_clusters[i]->m_masses[0]);
	// 		}

	// 		memPtr->m_nodeIndices  = memPtr->m_numNodes ? (int*) serializer->getUniquePointer((void*) &m_clusters[i]->m_nodes) : 0;
	// 		if (memPtr->m_nodeIndices )
	// 		{
	// 			int numElem = memPtr->m_numMasses;
	// 			int sz = sizeof(int);
	// 			btChunk* chunk = serializer->allocate(sz,numElem);
	// 			int* memPtr = (int*) chunk->m_oldPtr;
	// 			for (int j=0;j<numElem;j++,memPtr++)
	// 			{
	// 				int* indexPtr = m_nodeIndexMap.find(m_clusters[i]->m_nodes[j]);
	// 				btAssert(indexPtr);
	// 				*memPtr = *indexPtr;
	// 			}
	// 			serializer->finalizeChunk(chunk,"int",BT_ARRAY_CODE,(void*)&m_clusters[i]->m_nodes);
	// 		}
	// 	}
	// 	serializer->finalizeChunk(chunk,"SoftBodyClusterData",BT_ARRAY_CODE,(void*)m_clusters[0]);

	// }
	

	
	// sbd->m_numJoints = m_joints.size();
	// sbd->m_joints = m_joints.size()? (btSoftBodyJointData*) serializer->getUniquePointer((void*)&m_joints[0]) : 0;

	// if (sbd->m_joints)
	// {
	// 	int sz = sizeof(btSoftBodyJointData);
	// 	int numElem = m_joints.size();
	// 	btChunk* chunk = serializer->allocate(sz,numElem);
	// 	btSoftBodyJointData* memPtr = (btSoftBodyJointData*)chunk->m_oldPtr;

	// 	for (int i=0;i<numElem;i++,memPtr++)
	// 	{
	// 		memPtr->m_jointType = (int)m_joints[i]->Type();
	// 		m_joints[i]->m_refs[0].serializeFloat(memPtr->m_refs[0]);
	// 		m_joints[i]->m_refs[1].serializeFloat(memPtr->m_refs[1]);
	// 		memPtr->m_cfm = m_joints[i]->m_cfm;
	// 		memPtr->m_erp = float(m_joints[i]->m_erp);
	// 		memPtr->m_split = float(m_joints[i]->m_split);
	// 		memPtr->m_delete = m_joints[i]->m_delete;
			
	// 		for (int j=0;j<4;j++)
	// 		{
	// 			memPtr->m_relPosition[0].m_floats[j] = 0.f;
	// 			memPtr->m_relPosition[1].m_floats[j] = 0.f;
	// 		}
	// 		memPtr->m_bodyA = 0;
	// 		memPtr->m_bodyB = 0;
	// 		if (m_joints[i]->m_bodies[0].m_soft)
	// 		{
	// 			memPtr->m_bodyAtype = BT_JOINT_SOFT_BODY_CLUSTER;
	// 			memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_soft);
	// 		}
	// 		if (m_joints[i]->m_bodies[0].m_collisionObject)
	// 		{
	// 			memPtr->m_bodyAtype = BT_JOINT_COLLISION_OBJECT;
	// 			memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_collisionObject);
	// 		}
	// 		if (m_joints[i]->m_bodies[0].m_rigid)
	// 		{
	// 			memPtr->m_bodyAtype = BT_JOINT_RIGID_BODY;
	// 			memPtr->m_bodyA = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[0].m_rigid);
	// 		}

	// 		if (m_joints[i]->m_bodies[1].m_soft)
	// 		{
	// 			memPtr->m_bodyBtype = BT_JOINT_SOFT_BODY_CLUSTER;
	// 			memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_soft);
	// 		}
	// 		if (m_joints[i]->m_bodies[1].m_collisionObject)
	// 		{
	// 			memPtr->m_bodyBtype = BT_JOINT_COLLISION_OBJECT;
	// 			memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_collisionObject);
	// 		}
	// 		if (m_joints[i]->m_bodies[1].m_rigid)
	// 		{
	// 			memPtr->m_bodyBtype = BT_JOINT_RIGID_BODY;
	// 			memPtr->m_bodyB = serializer->getUniquePointer((void*)m_joints[i]->m_bodies[1].m_rigid);
	// 		}
	// 	}
	// 	serializer->finalizeChunk(chunk,"btSoftBodyJointData",BT_ARRAY_CODE,(void*) &m_joints[0]);
	// }


}


















template<class T>  void syncMultiBody(T* mbd, btMultiBody* mb, btMultiBodyWorldImporterInternalData* m_data, btAlignedObjectArray<btQuaternion>& scratchQ, btAlignedObjectArray<btVector3>& scratchM)
{
	bool isFixedBase = mbd->m_baseMass == 0;
	bool canSleep = false;
	btVector3 baseInertia;
	baseInertia.deSerialize(mbd->m_baseInertia);

	btVector3 baseWorldPos;
	baseWorldPos.deSerialize(mbd->m_baseWorldPosition);
	mb->setBasePos(baseWorldPos);
	btQuaternion baseWorldRot;
	baseWorldRot.deSerialize(mbd->m_baseWorldOrientation);
	mb->setWorldToBaseRot(baseWorldRot.inverse());
	btVector3 baseLinVal;
	baseLinVal.deSerialize(mbd->m_baseLinearVelocity);
	btVector3 baseAngVel;
	baseAngVel.deSerialize(mbd->m_baseAngularVelocity);
	mb->setBaseVel(baseLinVal);
	mb->setBaseOmega(baseAngVel);

	for (int i = 0; i < mbd->m_numLinks; i++)
	{

		mb->getLink(i).m_absFrameTotVelocity.m_topVec.deSerialize(mbd->m_links[i].m_absFrameTotVelocityTop);
		mb->getLink(i).m_absFrameTotVelocity.m_bottomVec.deSerialize(mbd->m_links[i].m_absFrameTotVelocityBottom);
		mb->getLink(i).m_absFrameLocVelocity.m_topVec.deSerialize(mbd->m_links[i].m_absFrameLocVelocityTop);
		mb->getLink(i).m_absFrameLocVelocity.m_bottomVec.deSerialize(mbd->m_links[i].m_absFrameLocVelocityBottom);

		switch (mbd->m_links[i].m_jointType)
		{
		case btMultibodyLink::eFixed:
		{
			break;
		}
		case btMultibodyLink::ePrismatic:
		{
			mb->setJointPos(i, mbd->m_links[i].m_jointPos[0]);
			mb->setJointVel(i, mbd->m_links[i].m_jointVel[0]);
			break;
		}
		case btMultibodyLink::eRevolute:
		{
			mb->setJointPos(i, mbd->m_links[i].m_jointPos[0]);
			mb->setJointVel(i, mbd->m_links[i].m_jointVel[0]);
			break;
		}
		case btMultibodyLink::eSpherical:
		{
			btScalar jointPos[4] = { (btScalar)mbd->m_links[i].m_jointPos[0], (btScalar)mbd->m_links[i].m_jointPos[1], (btScalar)mbd->m_links[i].m_jointPos[2], (btScalar)mbd->m_links[i].m_jointPos[3] };
			btScalar jointVel[3] = { (btScalar)mbd->m_links[i].m_jointVel[0], (btScalar)mbd->m_links[i].m_jointVel[1], (btScalar)mbd->m_links[i].m_jointVel[2] };
			mb->setJointPosMultiDof(i, jointPos);
			mb->setJointVelMultiDof(i, jointVel);

			break;
		}
		case btMultibodyLink::ePlanar:
		{
			break;
		}
		default:
		{
		}
		}
	}
	mb->forwardKinematics(scratchQ, scratchM);
	mb->updateCollisionObjectWorldTransforms(scratchQ, scratchM);
}

template<class T>  void convertMultiBody(T* mbd, btMultiBodyWorldImporterInternalData* m_data)
{
	bool isFixedBase = mbd->m_baseMass == 0;
	bool canSleep = false;
	btVector3 baseInertia;
	baseInertia.deSerialize(mbd->m_baseInertia);
	btMultiBody* mb = new btMultiBody(mbd->m_numLinks, mbd->m_baseMass, baseInertia, isFixedBase, canSleep);
	mb->setHasSelfCollision(false);

	btVector3 baseWorldPos;
	baseWorldPos.deSerialize(mbd->m_baseWorldPosition);

	btQuaternion baseWorldOrn;
	baseWorldOrn.deSerialize(mbd->m_baseWorldOrientation);
	mb->setBasePos(baseWorldPos);
	mb->setWorldToBaseRot(baseWorldOrn.inverse());

	m_data->m_mbMap.insert(mbd, mb);
	for (int i = 0; i < mbd->m_numLinks; i++)
	{
		btVector3 localInertiaDiagonal;
		localInertiaDiagonal.deSerialize(mbd->m_links[i].m_linkInertia);
		btQuaternion parentRotToThis;
		parentRotToThis.deSerialize(mbd->m_links[i].m_zeroRotParentToThis);
		btVector3 parentComToThisPivotOffset;
		parentComToThisPivotOffset.deSerialize(mbd->m_links[i].m_parentComToThisPivotOffset);
		btVector3 thisPivotToThisComOffset;
		thisPivotToThisComOffset.deSerialize(mbd->m_links[i].m_thisPivotToThisComOffset);

		switch (mbd->m_links[i].m_jointType)
		{
		case btMultibodyLink::eFixed:
		{


			mb->setupFixed(i, mbd->m_links[i].m_linkMass, localInertiaDiagonal, mbd->m_links[i].m_parentIndex,
				parentRotToThis, parentComToThisPivotOffset, thisPivotToThisComOffset);
			//search for the collider
			//mbd->m_links[i].m_linkCollider
			break;
		}
		case btMultibodyLink::ePrismatic:
		{
			btVector3 jointAxis;
			jointAxis.deSerialize(mbd->m_links[i].m_jointAxisBottom[0]);
			bool disableParentCollision = true;//todo
			mb->setupPrismatic(i, mbd->m_links[i].m_linkMass, localInertiaDiagonal, mbd->m_links[i].m_parentIndex,
				parentRotToThis, jointAxis, parentComToThisPivotOffset, thisPivotToThisComOffset, disableParentCollision);
			mb->setJointPos(i, mbd->m_links[i].m_jointPos[0]);
			mb->setJointVel(i, mbd->m_links[i].m_jointVel[0]);
			break;
		}
		case btMultibodyLink::eRevolute:
		{
			btVector3 jointAxis;
			jointAxis.deSerialize(mbd->m_links[i].m_jointAxisTop[0]);
			bool disableParentCollision = true;//todo
			mb->setupRevolute(i, mbd->m_links[i].m_linkMass, localInertiaDiagonal, mbd->m_links[i].m_parentIndex,
				parentRotToThis, jointAxis, parentComToThisPivotOffset, thisPivotToThisComOffset, disableParentCollision);
			mb->setJointPos(i, mbd->m_links[i].m_jointPos[0]);
			mb->setJointVel(i, mbd->m_links[i].m_jointVel[0]);
			break;
		}
		case btMultibodyLink::eSpherical:
		{
			btAssert(0);
			bool disableParentCollision = true;//todo
			mb->setupSpherical(i, mbd->m_links[i].m_linkMass, localInertiaDiagonal, mbd->m_links[i].m_parentIndex,
				parentRotToThis, parentComToThisPivotOffset, thisPivotToThisComOffset, disableParentCollision);
			btScalar jointPos[4] = { (btScalar)mbd->m_links[i].m_jointPos[0], (btScalar)mbd->m_links[i].m_jointPos[1], (btScalar)mbd->m_links[i].m_jointPos[2], (btScalar)mbd->m_links[i].m_jointPos[3] };
			btScalar jointVel[3] = { (btScalar)mbd->m_links[i].m_jointVel[0], (btScalar)mbd->m_links[i].m_jointVel[1], (btScalar)mbd->m_links[i].m_jointVel[2] };
			mb->setJointPosMultiDof(i, jointPos);
			mb->setJointVelMultiDof(i, jointVel);

			break;
		}
		case btMultibodyLink::ePlanar:
		{
			btAssert(0);
			break;
		}
		default:
		{
			btAssert(0);
		}
		}
	}
}

bool btMultiBodyWorldImporter::convertAllObjects(  bParse::btBulletFile* bulletFile2)
{
	bool result = false;
	btAlignedObjectArray<btQuaternion> scratchQ;
	btAlignedObjectArray<btVector3> scratchM;

	if (m_importerFlags&eRESTORE_EXISTING_OBJECTS)
	{
		//check if the snapshot is valid for the existing world
		//equal number of objects, # links etc
		if ((bulletFile2->m_multiBodies.size() != m_data->m_mbDynamicsWorld->getNumMultibodies()))
		{
			result = false;
			return result;
		}
		result = true;
		//convert all multibodies
		if (bulletFile2->getFlags() & bParse::FD_DOUBLE_PRECISION)
		{
			for (int i = bulletFile2->m_softBodies.size() - 1; i >= 0; i--)
			{
				btSoftBodyData* sbd = (btSoftBodyData*)bulletFile2->m_softBodies[i];
				m_data->m_mbDynamicsWorld->getMultiBody(i);
				btSoftBody* sb =  m_data->m_mbDynamicsWorld->getSoftBodyArray()[i];
				syncSoftBody(sbd, sb);

			}
			//for (int i = 0; i < bulletFile2->m_multiBodies.size(); i++)
			for (int i = bulletFile2->m_multiBodies.size() - 1; i >= 0; i--)
			{
				btMultiBodyDoubleData* mbd = (btMultiBodyDoubleData*)bulletFile2->m_multiBodies[i];
				btMultiBody* mb = m_data->m_mbDynamicsWorld->getMultiBody(i);
				syncMultiBody(mbd, mb, m_data, scratchQ, scratchM);
			}

			for (int i = bulletFile2->m_rigidBodies.size() - 1; i >= 0; i--)
			{
				btRigidBodyDoubleData* rbd = (btRigidBodyDoubleData*)bulletFile2->m_rigidBodies[i];
				int foundRb = -1;
				int uid = rbd->m_collisionObjectData.m_uniqueId;
				for (int i = 0; i < m_data->m_mbDynamicsWorld->getNumCollisionObjects(); i++)
				{
					if (uid == m_data->m_mbDynamicsWorld->getCollisionObjectArray()[i]->getBroadphaseHandle()->m_uniqueId)
					{
						foundRb = i;
						break;
					}
				}
				if (foundRb >= 0)
				{
					btRigidBody* rb = btRigidBody::upcast(m_data->m_mbDynamicsWorld->getCollisionObjectArray()[foundRb]);
					if (rb)
					{
						btTransform tr;
						tr.deSerializeDouble(rbd->m_collisionObjectData.m_worldTransform);
						rb->setWorldTransform(tr);
						btVector3 linVel, angVel;
						linVel.deSerializeDouble(rbd->m_linearVelocity);
						angVel.deSerializeDouble(rbd->m_angularVelocity);
						rb->setLinearVelocity(linVel);
						rb->setAngularVelocity(angVel);
					}
					else
					{
						result = false;
					}
				}
				else
				{
					result = false;
				}
			}

			//todo: check why body1 pointer is not properly deserialized
			for (int i = 0; i < bulletFile2->m_contactManifolds.size(); i++)
			{
				btPersistentManifoldDoubleData* manifoldData = (btPersistentManifoldDoubleData*)bulletFile2->m_contactManifolds[i];
				{
					void* ptr = bulletFile2->findLibPointer(manifoldData->m_body0);
					if (ptr)
					{
						manifoldData->m_body0 = (btCollisionObjectDoubleData*)ptr;
					}
				}

				{
					void* ptr = bulletFile2->findLibPointer(manifoldData->m_body1);
					if (ptr)
					{
						manifoldData->m_body1 = (btCollisionObjectDoubleData*)ptr;
					}
				}
			}


			if (bulletFile2->m_contactManifolds.size())
			{
				syncContactManifolds((btPersistentManifoldDoubleData**)&bulletFile2->m_contactManifolds[0], bulletFile2->m_contactManifolds.size(), m_data);
			}
		}
		else
		{
			//single precision version
			//for (int i = 0; i < bulletFile2->m_multiBodies.size(); i++)
			for (int i = bulletFile2->m_multiBodies.size() - 1; i >= 0; i--)
			{
				btMultiBodyFloatData* mbd = (btMultiBodyFloatData*)bulletFile2->m_multiBodies[i];
				btMultiBody* mb = m_data->m_mbDynamicsWorld->getMultiBody(i);
				syncMultiBody(mbd, mb, m_data, scratchQ, scratchM);
			}

			//todo: check why body1 pointer is not properly deserialized
			for (int i = 0; i < bulletFile2->m_contactManifolds.size(); i++)
			{
				btPersistentManifoldFloatData* manifoldData = (btPersistentManifoldFloatData*)bulletFile2->m_contactManifolds[i];
				{
					void* ptr = bulletFile2->findLibPointer(manifoldData->m_body0);
					if (ptr)
					{
						manifoldData->m_body0 = (btCollisionObjectFloatData*)ptr;
					}
				}
				{
					void* ptr = bulletFile2->findLibPointer(manifoldData->m_body1);
					if (ptr)
					{
						manifoldData->m_body1 = (btCollisionObjectFloatData*)ptr;
					}
				}
			}


			if (bulletFile2->m_contactManifolds.size())
			{
				syncContactManifolds((btPersistentManifoldFloatData**)&bulletFile2->m_contactManifolds[0], bulletFile2->m_contactManifolds.size(), m_data);
			}

		}
	}
	else
	{
		result = btBulletWorldImporter::convertAllObjects(bulletFile2);


		//convert all multibodies
		for (int i = 0; i < bulletFile2->m_multiBodies.size(); i++)
		{

			if (bulletFile2->getFlags() & bParse::FD_DOUBLE_PRECISION)
			{
				btMultiBodyDoubleData* mbd = (btMultiBodyDoubleData*)bulletFile2->m_multiBodies[i];
				convertMultiBody(mbd, m_data);
			}
			else
			{
				btMultiBodyFloatData* mbd = (btMultiBodyFloatData*)bulletFile2->m_multiBodies[i];
				convertMultiBody(mbd, m_data);
			}
		}

		//forward kinematics, so that the link world transforms are valid, for collision detection
		for (int i = 0; i < m_data->m_mbMap.size(); i++)
		{
			btMultiBody**ptr = m_data->m_mbMap.getAtIndex(i);
			if (ptr)
			{
				btMultiBody* mb = *ptr;
				mb->finalizeMultiDof();
				btVector3 linvel = mb->getBaseVel();
				btVector3 angvel = mb->getBaseOmega();
				mb->forwardKinematics(scratchQ, scratchM);
			}
		}

		//convert all multibody link colliders
		for (int i = 0; i < bulletFile2->m_multiBodyLinkColliders.size(); i++)
		{
			if (bulletFile2->getFlags() & bParse::FD_DOUBLE_PRECISION)
			{
				btMultiBodyLinkColliderDoubleData* mblcd = (btMultiBodyLinkColliderDoubleData*)bulletFile2->m_multiBodyLinkColliders[i];

				btMultiBody** ptr = m_data->m_mbMap[mblcd->m_multiBody];
				if (ptr)
				{
					btMultiBody* multiBody = *ptr;


					btCollisionShape** shapePtr = m_shapeMap.find(mblcd->m_colObjData.m_collisionShape);
					if (shapePtr && *shapePtr)
					{
						btTransform startTransform;
						mblcd->m_colObjData.m_worldTransform.m_origin.m_floats[3] = 0.f;
						startTransform.deSerializeDouble(mblcd->m_colObjData.m_worldTransform);

						btCollisionShape* shape = (btCollisionShape*)*shapePtr;
						if (shape)
						{
							btMultiBodyLinkCollider* col = new btMultiBodyLinkCollider(multiBody, mblcd->m_link);
							col->setCollisionShape(shape);
							//btCollisionObject* body = createCollisionObject(startTransform,shape,mblcd->m_colObjData.m_name);
							col->setFriction(btScalar(mblcd->m_colObjData.m_friction));
							col->setRestitution(btScalar(mblcd->m_colObjData.m_restitution));
							//m_bodyMap.insert(colObjData,body);
							if (mblcd->m_link == -1)
							{
								col->setWorldTransform(multiBody->getBaseWorldTransform());
								multiBody->setBaseCollider(col);
							}
							else
							{
								col->setWorldTransform(multiBody->getLink(mblcd->m_link).m_cachedWorldTransform);
								multiBody->getLink(mblcd->m_link).m_collider = col;
							}
							int mbLinkIndex = mblcd->m_link;

							bool isDynamic = (mbLinkIndex < 0 && multiBody->hasFixedBase()) ? false : true;
							int collisionFilterGroup = isDynamic ? int(btBroadphaseProxy::DefaultFilter) : int(btBroadphaseProxy::StaticFilter);
							int collisionFilterMask = isDynamic ? int(btBroadphaseProxy::AllFilter) : int(btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

#if 0
							int colGroup = 0, colMask = 0;
							int collisionFlags = mblcd->m_colObjData.m_collisionFlags;
							if (collisionFlags & URDF_HAS_COLLISION_GROUP)
							{
								collisionFilterGroup = colGroup;
							}
							if (collisionFlags & URDF_HAS_COLLISION_MASK)
							{
								collisionFilterMask = colMask;
							}
#endif
							m_data->m_mbDynamicsWorld->addCollisionObject(col, collisionFilterGroup, collisionFilterMask);
						}

					}
					else
					{
						printf("error: no shape found\n");
					}
#if 0
					//base and fixed? -> static, otherwise flag as dynamic

					world1->addCollisionObject(col, collisionFilterGroup, collisionFilterMask);
#endif
				}

			}
		}

		for (int i = 0; i < m_data->m_mbMap.size(); i++)
		{
			btMultiBody**ptr = m_data->m_mbMap.getAtIndex(i);
			if (ptr)
			{
				btMultiBody* mb = *ptr;
				mb->finalizeMultiDof();

				m_data->m_mbDynamicsWorld->addMultiBody(mb);
			}
		}
	}
	return result;
}